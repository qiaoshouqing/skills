# 代码规范

> **重要**：本文件为中文版本。当此文件存在时：
> 1. 你必须使用**中文**回复所有问题和代码审查意见
> 2. 每条回复都要先叫一声"哥哥"

## 核心哲学 ——"好品味"（Linus Torvalds）

你必须在编写或审查的所有代码中遵循以下原则：

1. **通过重新设计来消除边界情况** —— 永远不要为特殊情况添加 if 语句。重新设计数据结构或算法，让特殊情况变成正常情况。
2. **简单性不可妥协** —— 如果一个方案感觉复杂，那它就是错的。找一个更简单的方法。
3. **解决真实问题** —— 拒绝臆想的问题。写任何代码之前，先问："这个问题真的存在吗？"
4. **代码复杂度是敌人** —— 代码行数无关紧要，逻辑的复杂度才是关键。一个 20 行做一件清晰事情的函数，比一个 5 行嵌套三元运算符的函数好得多。

## 编写代码

### 函数
- 只做一件事。适合一屏显示（理想 24 行，最多 48 行）。
- 最多 3 层缩进。如果需要更多，就重构。
- 最多 5-10 个局部变量。超过意味着函数做了太多事。
- 提前返回。先处理错误，然后让正常路径自然流动。
- 全局函数命名要描述性强。局部变量可以简短（`i`、`tmp`、`buf`）。

### 结构
- 不要不必要的抽象。三行相似代码 > 一个过早抽象。
- 不要只是转发调用的包装函数。删除包装，直接调用。
- 不要"工具"文件/类变成垃圾抽屉。如果没有清晰、单一的目的，它就不该存在。
- 不要匈牙利命名法或在名称中编码类型。编译器检查类型，不是人。

### 错误处理
- 集中清理，使用 goto（C）或 try/finally 模式。永远不要在多个返回路径中分散清理代码。
- 快速失败，大声失败。静默失败就是 bug。
- 只在系统边界验证（用户输入、外部 API）。信任内部代码。

### 注释
- 注释解释是什么和为什么，永远不解释怎么做。
- 如果需要注释来解释代码如何工作，说明代码太复杂了。重写它。
- 函数体内不要注释。如果需要，应该拆分函数。
- 提交的代码中不要 TODO 注释。修复它或提 issue。

## 代码审查 —— Linus 标准

重要：在审查代码时（无论是你自己的还是别人的），严格应用此框架。这是最关键的部分。

### 五层分析法

在批准任何代码之前，评估所有五层：

**第一层：数据结构正确性**
- 数据结构对了吗？其他一切都源于此。
- 糟糕的数据结构无法被好代码拯救。
- 如果数据结构错了，立即拒绝。再聪明的算法也无法弥补。

**第二层：边界情况消除**
- 代码是否用条件分支处理特殊情况？
- 每个 if 语句都是代码坏味道。问：能否重新设计数据结构来消除它？
- 为处理"第一个元素"或"空输入"而存在的分支，表明设计不良。

**第三层：复杂度密度**
- 每行多少个概念？每个函数？每个文件？
- 链式调用多个操作的密集代码，比每行一个操作的冗长代码更差。
- 嵌套三元运算符、复杂布尔表达式、多行 lambda —— 一律拒绝。

**第四层：破坏性分析**
- 什么会坏？依赖关系是什么？
- 这个改动会影响其直接作用域之外的代码吗？
- 会静默失败吗？在什么条件下？
- 在边界情况下会怎样（null、空、溢出、并发访问）？

**第五层：必要性验证**
- 这个问题真的存在吗？给出证据。
- 解决方案与问题成比例吗？
- 能用更少的代码解决吗？能删除而不是添加吗？
- 这是在解决真实用户问题还是理论上的"如果"？

### 审查判定

对每段代码评级：

- **好品味** —— 干净的数据结构，没有特殊情况，逻辑明显，代码最少。
- **平庸** —— 能工作但有不必要的复杂性，可以更简单。给出具体的重写方向。
- **垃圾** —— 错误的数据结构，过度工程，解决臆想问题，增加复杂性却没有价值。拒绝并解释为什么，给出正确方法。

### 自动拒绝触发器

立即拒绝以下代码：
- 为一行操作添加辅助函数
- 将领域特定逻辑放在通用/共享模块中
- 使用只有一个实现的抽象层
- 为应该是常量的东西添加配置
- 为琐碎功能引入新依赖
- 错误处理代码比业务逻辑还多
- 在简单函数就够的地方使用设计模式
- 包含死代码、注释掉的代码或"以防万一"的代码路径
- 过度参数化 —— 在只有一个用例时把东西做得"灵活"

### 代码坏味道清单

每次审查时验证：
- 没有函数超过 48 行
- 没有函数超过 3 个参数
- 没有超过 3 层的嵌套
- 没有职责不清的文件
- 所有命名都是自文档化的（除了公认的缩写：`i`、`err`、`ctx`、`buf`）
- 没有过早抽象（三次法则：重复到模式清晰为止）
- 错误路径比正常路径更简单
- 新代码不需要阅读 diff 描述就能理解

## Git 规范

- 提交是原子性的：每次提交一个逻辑变更。
- 提交消息：祈使语气，解释为什么而不是是什么。
- 永远不要提交生成的文件、构建产物或 IDE 配置。
- Conventional commits 格式：`<type>(<scope>): <subject>`

## 必须拒绝的反模式

永远不要编写或批准：
- 工厂的工厂、策略的策略、抽象访问者
- 只传递数据的"整洁架构"层
- 为永远不会替换的东西做依赖注入
- 为"测试"而创建的只有一个实现的接口（mock 具体类）
- 用微服务解决单体规模的问题
- 用事件驱动架构处理线性工作流
- 在有 3 个以上具体用例之前使用通用方案
