# コード規約

> **重要**：このファイルは日本語版です。このファイルが存在する場合、すべての質問とコードレビューのコメントに**日本語**で回答してください。

## 核心哲学 ——「良いセンス」（Linus Torvalds）

あなたが書く、またはレビューするすべてのコードにおいて、以下の原則に従わなければならない：

1. **再設計によりエッジケースを排除する** —— 特殊なケースのために if 文を追加してはならない。データ構造やアルゴリズムを再設計し、特殊ケースが通常ケースになるようにする。
2. **シンプルさは妥協できない** —— ソリューションが複雑に感じるなら、それは間違っている。より簡単な方法を見つけよ。
3. **実在する問題を解決する** —— 想像上の問題を拒否する。コードを書く前に「この問題は本当に存在するか？」と問え。
4. **コードの複雑さは敵である** —— コード行数は無関係。ロジックの複雑さこそが問題。一つの明確なことを行う20行の関数は、ネストした三項演算子の5行の関数より優れている。

## コードを書く

### 関数
- 一つのことだけを行う。1画面に収まること（理想は24行、最大48行）。
- インデントは最大3レベル。それ以上必要なら、リファクタリングせよ。
- ローカル変数は最大5-10個。それ以上は関数がやりすぎている。
- 早期リターン。エラーを先に処理し、正常パスが自然に流れるようにする。
- グローバル関数は説明的に命名する。ローカル変数は簡潔でよい（`i`、`tmp`、`buf`）。

### 構造
- 不必要な抽象化をしない。3行の類似コード > 1つの早すぎる抽象化。
- 呼び出しを転送するだけのラッパー関数は不要。ラッパーを削除し、直接呼び出す。
- ゴミ箱化した「ユーティリティ」ファイル/クラスは不要。明確で単一の目的がなければ、存在すべきでない。
- ハンガリアン記法や名前への型エンコーディングは不要。型はコンパイラがチェックする。

### エラー処理
- goto（C）や try/finally パターンでクリーンアップを集中化する。複数のリターンパスにクリーンアップを分散させてはならない。
- 速く失敗し、大きく失敗する。サイレントな失敗はバグである。
- システム境界（ユーザー入力、外部API）でのみバリデーションする。内部コードは信頼する。

### コメント
- コメントは「何を」と「なぜ」を説明する。「どのように」は決して説明しない。
- コードの動作を説明するコメントが必要なら、コードが複雑すぎる。書き直せ。
- 関数本体内にコメントは書かない。必要なら、関数を分割すべき。
- コミットされたコードに TODO コメントは書かない。修正するか Issue を立てよ。

## コードレビュー —— Linus 基準

重要：コードをレビューする際（自分のものも他人のものも）、このフレームワークを厳格に適用せよ。これが最も重要なセクションである。

### 五層分析法

いかなるコードを承認する前にも、すべての五層を評価する：

**第1層：データ構造の正しさ**
- データ構造は正しいか？他のすべてはここから始まる。
- 悪いデータ構造は良いコードでは救えない。
- データ構造が間違っていたら、即座に拒否する。どんなに賢いアルゴリズムも補えない。

**第2層：エッジケースの排除**
- コードは条件分岐で特殊ケースを処理しているか？
- 各 if 文はコードの臭い。問え：データ構造を再設計してこれを排除できないか？
- 「最初の要素」や「空の入力」を処理するために存在する分岐は、設計の悪さを示す。

**第3層：複雑さの密度**
- 1行あたり何個の概念か？関数あたりは？ファイルあたりは？
- 複数の操作をチェーンした密なコードは、1行1操作の冗長なコードよりも悪い。
- ネストした三項演算子、複雑なブール式、複数行のラムダ —— すべて拒否。

**第4層：破壊的分析**
- 何が壊れうるか？依存関係は何か？
- この変更は直接のスコープ外のコードに影響するか？
- サイレントに失敗しうるか？どのような条件で？
- 境界で何が起きるか（null、空、オーバーフロー、並行アクセス）？

**第5層：必要性の検証**
- この問題は本当に存在するか？証拠を示せ。
- ソリューションは問題に比例しているか？
- より少ないコードで解決できないか？追加ではなく削除できないか？
- これは実際のユーザー問題を解決しているか、それとも理論上の「もしも」か？

### レビュー判定

すべてのコードを評価する：

- **良いセンス** —— クリーンなデータ構造、特殊ケースなし、明白なロジック、最小限のコード。
- **凡庸** —— 動くが不必要な複雑さがある、もっと簡単にできる。具体的な書き直しの方向を示す。
- **ゴミ** —— 間違ったデータ構造、過剰設計、想像上の問題を解決、価値なく複雑さを増加。なぜかを説明して拒否し、正しいアプローチを提示する。

### 自動拒否トリガー

以下のコードは即座に拒否する：
- 1行の操作のためにヘルパー関数を追加
- ドメイン固有のロジックを汎用/共有モジュールに配置
- 実装が1つしかない抽象化レイヤーを使用
- 定数であるべきものに設定を追加
- 些細な機能のために新しい依存関係を導入
- エラー処理コードがビジネスロジックより多い
- 単純な関数で十分な場所にデザインパターンを使用
- デッドコード、コメントアウトされたコード、「念のため」のコードパスを含む
- 過剰パラメータ化 —— ユースケースが1つしかないのに「柔軟」にする

### コードの臭いチェックリスト

すべてのレビューで確認する：
- 48行を超える関数がない
- 3つ以上のパラメータを持つ関数がない
- 3レベル以上のネストがない
- 責務が不明確なファイルがない
- すべての名前が自己文書化されている（普遍的に知られた略語を除く：`i`、`err`、`ctx`、`buf`）
- 早すぎる抽象化がない（3回の法則：パターンが明確になるまで重複させる）
- エラーパスが正常パスより簡単
- 新しいコードが diff の説明を読まなくても理解できる

## Git 規律

- コミットはアトミック：1コミットに1つの論理的変更。
- コミットメッセージ：命令形、何をではなくなぜを説明する。
- 生成ファイル、ビルド成果物、IDE 設定は決してコミットしない。
- Conventional commits 形式：`<type>(<scope>): <subject>`

## 拒否すべきアンチパターン

決して書いたり承認してはならない：
- ファクトリのファクトリ、ストラテジのストラテジ、抽象ビジター
- データを通過させるだけの「クリーンアーキテクチャ」層
- 決して置き換えられないもののための依存性注入
- 「テスト」のための実装が1つしかないインターフェース（具象クラスをモックせよ）
- モノリス規模の問題にマイクロサービス
- 線形ワークフローにイベント駆動アーキテクチャ
- 3つ以上の具体的なユースケースがない段階での汎用ソリューション
